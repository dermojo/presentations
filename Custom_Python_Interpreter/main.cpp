/**
 * Python interpreter main program.
 * This is a restricted version of Modules/main.c from the Python source tree.
 *
 * This interpreter is limited to only execute:
 *  (1) scripts with a valid detached signature,
 *  (2) "stand-alone" scripts with an integrated signature,
 *  (3) anything else if you know the secret password...
 *
 * The main things removed from the Python interpreter are:
 *  - most command line options,
 *  - environment variable support (making "-I" the default).
 */

// note: expects Python 3
#include <Python.h>
#include <osdefs.h>
#include <pygetopt.h>

#include <locale.h>

#include "accesscontrol.hpp"

/* command line options */
static wchar_t PROGRAM_OPTS[] = L"bBhOqSVW:xX:?";

/* Long usage message, split into parts < 512 bytes */
static const char* usage_1 = "\
Options and arguments (and corresponding environment variables):\n\
-b     : issue warnings about str(bytes_instance), str(bytearray_instance)\n\
         and comparing bytes/bytearray with str. (-bb: issue errors)\n\
-B     : don't write .py[co] files on import\n\
-h     : print this help message and exit (also --help)\n\
";
static const char* usage_2 = "\
-O     : optimize generated bytecode slightly\n\
-OO    : remove doc-strings in addition to the -O optimizations\n\
-q     : don't print version and copyright messages on interactive startup\n\
-S     : don't imply 'import site' on initialization\n\
";
static const char* usage_3 = "\
-V     : print the Python version number and exit (also --version)\n\
-W arg : warning control; arg is action:message:category:module:lineno\n\
-x     : skip first line of source, allowing use of non-Unix forms of #!cmd\n\
-X opt : set implementation-specific option\n\
";
static const char* usage_4 = "\
file   : program read from script file\n\
-      : program read from stdin (default; interactive mode if a tty)\n\
arg ...: arguments passed to program in sys.argv[1:]\n\n\
";

static int usage(int exitcode, const wchar_t* program)
{
    FILE* f = exitcode ? stderr : stdout;

    fprintf(f, "usage: %ls [option] ... [-m mod | file | -] [arg] ...\n", program);
    if (exitcode)
        fprintf(f, "Try `%ls -h' for more information.\n", program);
    else
    {
        fputs(usage_1, f);
        fputs(usage_2, f);
        fputs(usage_3, f);
        fputs(usage_4, f);
    }
    return exitcode;
}

static int RunModule(const wchar_t* modname, int set_argv0)
{
    PyObject* runpy = PyImport_ImportModule("runpy");
    if (runpy == NULL)
    {
        fprintf(stderr, "Could not import runpy module\n");
        PyErr_Print();
        return -1;
    }
    PyObject* runmodule = PyObject_GetAttrString(runpy, "_run_module_as_main");
    if (runmodule == NULL)
    {
        fprintf(stderr, "Could not access runpy._run_module_as_main\n");
        PyErr_Print();
        Py_DECREF(runpy);
        return -1;
    }
    PyObject* module = PyUnicode_FromWideChar(modname, wcslen(modname));
    if (module == NULL)
    {
        fprintf(stderr, "Could not convert module name to unicode\n");
        PyErr_Print();
        Py_DECREF(runpy);
        Py_DECREF(runmodule);
        return -1;
    }
    PyObject* runargs = Py_BuildValue("(Oi)", module, set_argv0);
    if (runargs == NULL)
    {
        fprintf(stderr, "Could not create arguments for runpy._run_module_as_main\n");
        PyErr_Print();
        Py_DECREF(runpy);
        Py_DECREF(runmodule);
        Py_DECREF(module);
        return -1;
    }
    PyObject* result = PyObject_Call(runmodule, runargs, NULL);
    if (result == NULL)
    {
        PyErr_Print();
    }
    Py_DECREF(runpy);
    Py_DECREF(runmodule);
    Py_DECREF(module);
    Py_DECREF(runargs);
    if (result == NULL)
    {
        return -1;
    }
    Py_DECREF(result);
    return 0;
}

static PyObject* mymod_foo(PyObject* self, PyObject* args)
{
    // ignore args for now
    (void)self;
    (void)args;
    return PyLong_FromLong(42);
}

static PyMethodDef mymod_methods[] = {
    { "foo", mymod_foo, METH_VARARGS, "Do some foo." },
    { NULL, NULL, 0, NULL } /* Sentinel */
};

static struct PyModuleDef mymod_module = {
    PyModuleDef_HEAD_INIT, "mymod", /* name of module */
    NULL,                           /* module documentation, may be NULL */
    -1,                             /* size of per-interpreter state of the module,
                                       or -1 if the module keeps state in global variables. */
    mymod_methods
};

static PyObject* init_mymod()
{
    return PyModule_Create(&mymod_module);
}

static void initModules(void)
{
    PyImport_AppendInittab("mymod", init_mymod);
}

static void RunInteractiveHook(void)
{
    PyObject *sys, *hook, *result;
    sys = PyImport_ImportModule("sys");
    if (sys == NULL)
        goto error;
    hook = PyObject_GetAttrString(sys, "__interactivehook__");
    Py_DECREF(sys);
    if (hook == NULL)
        PyErr_Clear();
    else
    {
        result = PyObject_CallObject(hook, NULL);
        Py_DECREF(hook);
        if (result == NULL)
            goto error;
        else
            Py_DECREF(result);
    }
    return;

error:
    PySys_WriteStderr("Failed calling sys.__interactivehook__\n");
    PyErr_Print();
    PyErr_Clear();
}

static int RunMainFromImporter(const wchar_t* filename)
{
    PyObject *argv0 = NULL, *importer, *sys_path;
    int sts;

    argv0 = PyUnicode_FromWideChar(filename, wcslen(filename));
    if (argv0 == NULL)
        goto error;

    importer = PyImport_GetImporter(argv0);
    if (importer == NULL)
        goto error;

    if (importer == Py_None)
    {
        Py_DECREF(argv0);
        Py_DECREF(importer);
        return -1;
    }
    Py_DECREF(importer);

    /* argv0 is usable as an import source, so put it in sys.path[0]
       and import __main__ */
    sys_path = PySys_GetObject("path");
    if (sys_path == NULL)
    {
        PyErr_SetString(PyExc_RuntimeError, "unable to get sys.path");
        goto error;
    }
    if (PyList_SetItem(sys_path, 0, argv0))
    {
        argv0 = NULL;
        goto error;
    }
    Py_INCREF(argv0);

    sts = RunModule(L"__main__", 0);
    return sts != 0;

error:
    Py_XDECREF(argv0);
    PyErr_Print();
    return 1;
}

static int run_file(FILE* fp, const wchar_t* filename, PyCompilerFlags* p_cf)
{
    PyObject *unicode, *bytes = NULL;
    const char* filename_str;
    int run;

    /* call pending calls like signal handlers (SIGINT) */
    if (Py_MakePendingCalls() == -1)
    {
        PyErr_Print();
        return 1;
    }

    if (filename)
    {
        unicode = PyUnicode_FromWideChar(filename, wcslen(filename));
        if (unicode != NULL)
        {
            bytes = PyUnicode_EncodeFSDefault(unicode);
            Py_DECREF(unicode);
        }
        if (bytes != NULL)
            filename_str = PyBytes_AsString(bytes);
        else
        {
            PyErr_Clear();
            filename_str = "<encoding error>";
        }
    }
    else
        filename_str = "<stdin>";

    run = PyRun_AnyFileExFlags(fp, filename_str, filename != NULL, p_cf);
    Py_XDECREF(bytes);
    return run != 0;
}

/// RAII wrapper for interpreter initialization and cleanup
class Interpreter
{
public:
    Interpreter() { Py_Initialize(); }
    ~Interpreter() { Py_Finalize(); }
};

/* Main program */

int Py_Main(int argc, wchar_t** argv)
{
    int c;
    int sts = 0;
    wchar_t* filename = NULL;
    FILE* fp = stdin;
    int stdin_is_interactive = 0;
    int help = 0;
    int version = 0;
    PyCompilerFlags cf;
    PyObject* warning_option = NULL;
    PyObject* warning_options = NULL;

    cf.cf_flags = 0;

    // make "-I" the default: ignore environment variables, user sites etc.
    Py_IsolatedFlag++;
    Py_NoUserSiteDirectory++;
    Py_IgnoreEnvironmentFlag++;

    _PyOS_opterr = 0; /* prevent printing the error in 1st pass */
    while ((c = _PyOS_GetOpt(argc, argv, PROGRAM_OPTS)) != EOF)
    {
        if (c == 'm')
        {
            /* -m is the last option: following arguments are
               not interpreter options. */
            break;
        }
    }

    Py_HashRandomizationFlag = 1;
    _PyRandom_Init();

    PySys_ResetWarnOptions();
    _PyOS_ResetGetOpt();

    while ((c = _PyOS_GetOpt(argc, argv, PROGRAM_OPTS)) != EOF)
    {
        switch (c)
        {
        case 'b':
            Py_BytesWarningFlag++;
            break;

        case 'O':
            Py_OptimizeFlag++;
            break;

        case 'B':
            Py_DontWriteBytecodeFlag++;
            break;

        case 'h':
        case '?':
            help++;
            break;

        case 'V':
            version++;
            break;

        case 'W':
            if (warning_options == NULL)
                warning_options = PyList_New(0);
            if (warning_options == NULL)
                Py_FatalError("failure in handling of -W argument");
            warning_option = PyUnicode_FromWideChar(_PyOS_optarg, -1);
            if (warning_option == NULL)
                Py_FatalError("failure in handling of -W argument");
            PyList_Append(warning_options, warning_option);
            Py_DECREF(warning_option);
            break;

        case 'X':
            PySys_AddXOption(_PyOS_optarg);
            break;

        case 'q':
            Py_QuietFlag++;
            break;

        /* This space reserved for other options */

        default:
            return usage(2, argv[0]);
            /*NOTREACHED*/
        }
    }

    if (help)
        return usage(0, argv[0]);

    if (version)
    {
        printf("Python %s\n", PY_VERSION);
        return 0;
    }

    if (warning_options != NULL)
    {
        Py_ssize_t i;
        for (i = 0; i < PyList_GET_SIZE(warning_options); i++)
        {
            PySys_AddWarnOptionUnicode(PyList_GET_ITEM(warning_options, i));
        }
    }

    if (_PyOS_optind < argc && wcscmp(argv[_PyOS_optind], L"-") != 0)
    {
        filename = argv[_PyOS_optind];
    }

    stdin_is_interactive = Py_FdIsInteractive(stdin, (char*)0);

#if defined(MS_WINDOWS) || defined(__CYGWIN__)
    /* don't translate newlines (\r\n <=> \n) */
    _setmode(fileno(stdin), O_BINARY);
    _setmode(fileno(stdout), O_BINARY);
    _setmode(fileno(stderr), O_BINARY);
#endif

    //
    // removed unbuffered I/O support
    //

    // initialize our modules
    initModules();

    Py_SetProgramName(argv[0]);
    // RAII (de)initialization
    Interpreter intp;
    Py_XDECREF(warning_options);

    // disable some stuff that can be done in "plain vanilla" Python
    Py_InspectFlag = 0; /* do exit on SystemExit */
    Py_VerboseFlag = 0;

    PySys_SetArgv(argc - _PyOS_optind, argv + _PyOS_optind);

    if (filename == NULL && isatty(fileno(stdin)))
    {
        PyObject* v;
        v = PyImport_ImportModule("readline");
        if (v == NULL)
            PyErr_Clear();
        else
            Py_DECREF(v);
    }

    if (filename)
    {
        const auto sigStatus = checkFileSignature(filename);
        if (sigStatus == SignatureStatus::INVALID)
        {
            fprintf(stderr, "Error: invalid signature for '%ls'\n", filename);
            return 1;
        }

        // if not signed, interactive check required
        if (sigStatus == SignatureStatus::UNSIGNED &&
            !checkInteractiveAccess((bool)stdin_is_interactive))
        {
            fprintf(stderr, "Error: interactive access denied\n");
            return 1;
        }
    }
    else
    {
        // check interactive access
        if (!checkInteractiveAccess((bool)stdin_is_interactive))
        {
            fprintf(stderr, "Error: interactive access denied\n");
            return 1;
        }

        if (stdin_is_interactive)
        {
            RunInteractiveHook();
        }
    }

    if (true)
    {
        sts = -1; /* keep track of whether we've already run __main__ */

        if (filename != NULL)
        {
            sts = RunMainFromImporter(filename);
        }

        if (sts == -1 && filename != NULL)
        {
            fp = _Py_wfopen(filename, L"r");
            if (fp == NULL)
            {
                char* cfilename_buffer;
                const char* cfilename;
                int err = errno;
                cfilename_buffer = Py_EncodeLocale(filename, NULL);
                if (cfilename_buffer != NULL)
                    cfilename = cfilename_buffer;
                else
                    cfilename = "<unprintable file name>";
                fprintf(stderr, "%ls: can't open file '%s': [Errno %d] %s\n", argv[0], cfilename,
                        err, strerror(err));
                if (cfilename_buffer)
                    PyMem_Free(cfilename_buffer);
                return 2;
            }

            {
                struct _Py_stat_struct sb;
                if (_Py_fstat_noraise(fileno(fp), &sb) == 0 && S_ISDIR(sb.st_mode))
                {
                    fprintf(stderr, "%ls: '%ls' is a directory, cannot continue\n", argv[0],
                            filename);
                    fclose(fp);
                    return 1;
                }
            }
        }

        if (sts == -1)
            sts = run_file(fp, filename, &cf);
    }

    Py_Finalize();

    return sts;
}

#ifdef MS_WINDOWS
int wmain(int argc, wchar_t** argv)
{
    return Py_Main(argc, argv);
}
#else

int main(int argc, char** argv)
{
    wchar_t** argv_copy;
    /* We need a second copy, as Python might modify the first one. */
    wchar_t** argv_copy2;
    int i, res;
    char* oldloc;

    argv_copy = (wchar_t**)PyMem_RawMalloc(sizeof(wchar_t*) * (argc + 1));
    argv_copy2 = (wchar_t**)PyMem_RawMalloc(sizeof(wchar_t*) * (argc + 1));
    if (!argv_copy || !argv_copy2)
    {
        fprintf(stderr, "out of memory\n");
        return 1;
    }

    oldloc = _PyMem_RawStrdup(setlocale(LC_ALL, NULL));
    if (!oldloc)
    {
        fprintf(stderr, "out of memory\n");
        return 1;
    }

    setlocale(LC_ALL, "");
    for (i = 0; i < argc; i++)
    {
        argv_copy[i] = Py_DecodeLocale(argv[i], NULL);
        if (!argv_copy[i])
        {
            PyMem_RawFree(oldloc);
            fprintf(stderr, "Fatal Python error: "
                            "unable to decode the command line argument #%i\n",
                    i + 1);
            return 1;
        }
        argv_copy2[i] = argv_copy[i];
    }
    argv_copy2[argc] = argv_copy[argc] = NULL;

    setlocale(LC_ALL, oldloc);
    PyMem_RawFree(oldloc);
    res = Py_Main(argc, argv_copy);
    for (i = 0; i < argc; i++)
    {
        PyMem_RawFree(argv_copy2[i]);
    }
    PyMem_RawFree(argv_copy);
    PyMem_RawFree(argv_copy2);
    return res;
}
#endif
